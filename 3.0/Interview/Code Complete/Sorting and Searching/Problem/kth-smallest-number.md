# Kth Smallest Number

输入`n`个整数，输出其中最小的`k`个。

## 分析与解法

### 解法一

要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为`n*logn` ），然后再遍历序列中前`k`个元素输出即可。因此，总的时间复杂度：`O(n*log n)+O(k)=O(n*log n)`。

### 解法二

咱们再进一步想想，题目没有要求最小的`k`个数有序，也没要求最后`n-k`个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：

1. 遍历`n`个数，把最先遍历到的`k`个数存入到大小为`k`的数组中，假设它们即是最小的`k`个数； 
2. 对这`k`个数，利用选择或交换排序找到这`k`个元素中的最大值`kmax`（找最大值需要遍历这`k`个数，时间复杂度为`O(k)`） 
3. 继续遍历剩余`n-k`个数。假设每一次遍历到的新的元素的值为`x`，把`x`与`kmax`比较：如果`x < kmax`  ，用`x`替换`kmax`，并回到第二步重新找出`k`个元素的数组中最大元素`kmax'`；如果  `x >= kmax`  ，则继续遍历不更新数组。

每次遍历，更新或不更新数组的所用的时间为`O(k)`或`O(0)`。故整趟下来，时间复杂度为`n*O(k)=O(n*k)。

### 解法三

更好的办法是维护容量为`k`的最大堆，原理跟解法二的方法相似：

1. 用容量为`k`的最大堆存储最先遍历到的`k`个数，同样假设它们即是最小的`k`个数；
2. 堆中元素是有序的，令`k1<k2<...<kmax`（`kmax`设为最大堆中的最大元素）
3. 遍历剩余`n-k`个数。假设每一次遍历到的新的元素的值为`x`，把`x`与堆顶元素`kmax`比较：如果`x < kmax`  ，用`x`替换`kmax`，然后更新堆（用时`logk`）；否则不更新堆。

这样下来，总的时间复杂度:`O(k+(n-k)*logk)=O(n*logk)`  。此方法得益于堆中进行查找和更新的时间复杂度均为：`O(logk)` （若使用解法二：在数组中找出最大元素，时间复杂度：`O(k)`）  。

### 解法四

在《数据结构与算法分析--C语言描述》一书，第`7`章第`7.7.6`节中，阐述了一种在平均情况下，时间复杂度为 `O(N)`的快速选择算法。如下述文字：

+ 选取`S`中一个元素作为枢纽元`v`，将集合`S-{v}`分割成`S1`和`S2`，就像快速排序那样
+ 如果`k <= |S1|`，那么第`k`个最小元素必然在`S1`中。在这种情况下，返回`QuickSelect(S1, k)`。
+ 如果`k = 1 + |S1|`，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
+ 否则，这第`k`个最小元素就在`S2`中，即`S2`中的第`k-|S1|-1`个最小元素，我们递归调用并返回`QuickSelect(S2, k-|S1|-1)`。

此算法的平均运行时间为`O(n)`。

示例代码如下：

```cpp
//QuickSelect 将第k小的元素放在 a[k-1]  
void QuickSelect( int a[], int k, int left, int right )
{
    int i, j;
    int pivot;

    if( left + cutoff <= right )
    {
        pivot = median3( a, left, right );
        //取三数中值作为枢纽元，可以很大程度上避免最坏情况
        i = left; j = right - 1;
        for( ; ; )
        {
            while( a[ ++i ] < pivot ){ }
            while( a[ --j ] > pivot ){ }
            if( i < j )
                swap( &a[ i ], &a[ j ] );
            else
                break;
        }
        //重置枢纽元
        swap( &a[ i ], &a[ right - 1 ] );  

        if( k <= i )
            QuickSelect( a, k, left, i - 1 );
        else if( k > i + 1 )
            QuickSelect( a, k, i + 1, right );
    }
    else  
        InsertSort( a + left, right - left + 1 );
}
```

这个快速选择`SELECT`算法，类似快速排序的划分方法。`N`个数存储在数组`S`中，再从数组中选取“中位数的中位数”作为枢纽元`X`，把数组划分为`Sa`和`Sb`俩部分，`Sa<=X<=Sb`，如果要查找的`k`个元素小于`Sa`的元素个数，则返回`Sa`中较小的`k`个元素，否则返回`Sa中所有元素`+`Sb中小的k-|Sa|个元素`，这种解法在平均情况下能做到`O(n)`的复杂度。

更进一步，《算法导论》第`9`章第`9.3`节介绍了一个最坏情况下亦为`O(n)`时间的`SELECT`算法，有兴趣的读者可以参看。

## 举一反三

一：谷歌面试题，输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？

分析：

假设两个整数数组为`A`和`B`，各有`N`个元素，任意两个数的和组成的数组`C`有`N^2`个元素。那么可以把这些和看成`N`个有序数列：

    A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <=…
    A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <=…
    …
    A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <=…
    
问题转变成，在这`N^2`个有序数列里，找到前`k`小的元素

二：有两个序列`A`和`B`,`A=(a1,a2,...,ak)`,`B=(b1,b2,...,bk)`，`A`和`B`都按升序排列。对于`1<=i,j<=k`，求`k`个最小的`ai+bj`。要求算法尽量高效。

3、给定一个数列`a1,a2,a3,...,an`和`m`个三元组表示的查询，对于每个查询`(i，j，k)`，输出`ai，ai+1，...，aj`的升序排列中第`k`个数。

